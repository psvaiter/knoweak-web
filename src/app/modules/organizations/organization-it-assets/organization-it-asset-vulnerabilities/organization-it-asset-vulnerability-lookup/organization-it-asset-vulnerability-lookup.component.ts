import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';

import { BsModalRef } from 'ngx-bootstrap/modal';
import { finalize } from 'rxjs/operators';
import * as _ from 'lodash';

import { Constants } from '../../../../../shared/constants';
import { OrganizationSecurityThreatService } from '../../../../../services/api/organization/organization-security-threat.service';
import { OrganizationItAssetVulnerabilityService } from '../../../../../services/api/organization/organization-it-asset-vulnerability.service';
import { Organization, OrganizationItAsset } from '../../../organization';
import { Utils } from '../../../../../shared/utils';

@Component({
  selector: 'app-organization-it-asset-vulnerability-lookup',
  templateUrl: './organization-it-asset-vulnerability-lookup.component.html',
  styleUrls: ['./organization-it-asset-vulnerability-lookup.component.scss']
})
export class OrganizationItAssetVulnerabilityLookupComponent implements OnInit {

  @Input() organization: Organization;
  @Input() itAsset: OrganizationItAsset;
  @Input() vulnerability: any;
  @Output() added = new EventEmitter();

  loadingSecurityThreats: boolean;
  securityThreats: any[];
  ratingLevels = Constants.RATING_LEVELS;

  selectedSecurityThreatId: number;
  selectedVulnerabilityLevelId: number;
  editMode: boolean;
  persisting: boolean;
  errors: any[];

  fieldLabels = new Map([
    ["securityThreatId", "Ameaça"],
    ["vulnerabilityLevelId", "Grau da vulnerabilidade"],
    ["itAssetInstanceId/securityThreatId", "Ameaça para ativo de TI"]
  ]);

  constructor(
    private modalRef: BsModalRef,
    private organizationSecurityThreatService: OrganizationSecurityThreatService,
    private organizationItAssetVulnerabilityService: OrganizationItAssetVulnerabilityService
  ) { 

  }

  ngOnInit() {
    this.loadSecurityThreats();
    
    if (this.vulnerability) {
      this.editMode = true;
      this.selectedSecurityThreatId = this.vulnerability.securityThreat.id;

      if (this.vulnerability.level) {
        this.selectedVulnerabilityLevelId = this.vulnerability.level.id;
      }
    }
  }

  confirm() {
    this.errors = null;

    if (!this.editMode) {
      this.addVulnerability();
    }
    else {
      this.patchVulnerability();
    }
  }

  hide() {
    this.modalRef.hide();
  }

  disableSave() {
    if (this.persisting) {
      return true;
    }
    if (!this.selectedSecurityThreatId || !this.selectedVulnerabilityLevelId) {
      return true;
    }
    return false;
  }

  private loadSecurityThreats() {
    this.loadingSecurityThreats = true;
    this.organizationSecurityThreatService.listSecurityThreats(this.organization.id, 1, 100)
      .pipe(finalize(() => this.loadingSecurityThreats = false))
      .subscribe(
        response => {
          let securityThreats = response['data'].map(item => {
            return {
              id: item.securityThreat.id,
              name: item.securityThreat.name
            };
          });

          this.securityThreats = _.orderBy(securityThreats, ['name']);
        }
      );
  }

  private addVulnerability() {
    let request = {
      securityThreatId: this.selectedSecurityThreatId,
      vulnerabilityLevelId: this.selectedVulnerabilityLevelId
    };

    this.persisting = true;
    this.organizationItAssetVulnerabilityService
      .addVulnerability(this.organization.id, this.itAsset.instanceId, request)
      .pipe(finalize(() => this.persisting = false))
      .subscribe(
        response => {
          this.added.emit(request);
        },
        err => {
          this.errors = Utils.getErrors(err, this.fieldLabels);
        }
      );
  }

  private patchVulnerability() {
    let request = {
      vulnerabilityLevelId: this.selectedVulnerabilityLevelId
    };

    this.persisting = true;
    this.organizationItAssetVulnerabilityService
      .patchVulnerability(this.organization.id, this.itAsset.instanceId, this.vulnerability.securityThreat.id, request)
      .pipe(finalize(() => this.persisting = false))
      .subscribe(
        response => {
          this.added.emit(request);
        },
        err => {
          this.errors = Utils.getErrors(err, this.fieldLabels);
        }
      );
  }

}
